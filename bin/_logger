#!/usr/bin/perl
# -*- mode: perl; indent-tabs-mode: t; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=perl
#

use strict;
use warnings;

use Time::HiRes qw(time);
use IO::Select;
use DBI;
use threads;
use threads::shared;
use Thread::Semaphore;

# disable STDOUT output buffering
$|++;

my $source = $ARGV[0];
my $command = $ARGV[1];
my $log_filename = $ARGV[2];
my $stdout_pipe = $ARGV[3];
my $stderr_pipe = $ARGV[4];

my $start_timestamp = time();
my $session_id;

my $log_dbh;
my $stdout_fh;
my $stderr_fh;

# prevent CTRL-C from tearing down the logger while it is processing
# the logger should gracefully exit on it's own
$SIG{'INT'} = sub { my $foo = 1; };

$log_dbh = DBI->connect("dbi:SQLite:dbname=" . $log_filename, "", "", { PrintError => 0 });
if (! $log_dbh) {
    printf("ERROR: Logger could not open SQLite DB '%s'!\n", $log_filename);
    exit(1);
} else {
    my $log_open_error = 0;

    my $rv = $log_dbh->do("SELECT timestamp FROM db_state;") or $log_open_error = 1;

    if ($log_open_error) {
	printf("ERROR: The SQLite log DB '%s' does not appear to be initialized!\n", $log_filename);
	exit(1);
    } else {
	if ($rv < 0) {
	    print $DBI::errstr;
	    exit(1);
	}

	$rv = $log_dbh->do("UPDATE db_state SET timestamp=$start_timestamp;");
	if ($rv < 0) {
	    print $DBI::errstr;
	    exit(1);
	}
    }

    my $sth = $log_dbh->prepare("SELECT id FROM sources WHERE source=" . $log_dbh->quote($source) . ";");
    $rv = $sth->execute() or die $DBI::errstr;
    if ($rv < 0) {
	print $DBI::errstr;
	exit(1);
    }

    my $source_id;
    my $rows = 0;
    while (my $row = $sth->fetchrow_hashref()) {
	$source_id = $row->{'id'};
	$rows += 1;
    }

    if ($rows == 0) {
	$rv = $log_dbh->do("INSERT INTO sources (source) VALUES (" . $log_dbh->quote($source) . ");");
	if ($rv < 0) {
	    print $DBI::errstr;
	    exit(1);
	}
	$source_id = $log_dbh->last_insert_id("", "", "sources", "");
    }

    $sth = $log_dbh->prepare("SELECT id FROM commands WHERE command=" . $log_dbh->quote($command) . ";");
    $rv = $sth->execute() or die $DBI::errstr;
    if ($rv < 0) {
	print $DBI::errstr;
	exit(1);
    }

    my $command_id;
    $rows = 0;
    while (my $row = $sth->fetchrow_hashref()) {
	$command_id = $row->{'id'};
	$rows += 1;
    }

    if ($rows == 0) {
	$rv = $log_dbh->do("INSERT INTO commands (command) VALUES (" . $log_dbh->quote($command) . ");");
	if ($rv < 0) {
	    print $DBI::errstr;
	    exit(1);
	}
	$command_id = $log_dbh->last_insert_id("", "", "commands", "");
    }

    $rv = $log_dbh->do("INSERT INTO sessions (timestamp, source, command) VALUES ($start_timestamp, $source_id, $command_id);");
    if ($rv < 0) {
	print $DBI::errstr;
	exit(1);
    }
    $session_id = $log_dbh->last_insert_id("", "", "sessions", "");
}

if (!open($stdout_fh, "<", $stdout_pipe)) {
    printf("ERROR: Logger could not open the stdout pipe '%s'!\n", $stdout_pipe);
    exit(1);
}

if (!open($stderr_fh, "<", $stderr_pipe)) {
    printf("ERROR: Logger could not open the stderr pipe '%s'!\n", $stderr_pipe);
    exit(1);
}

my $s = IO::Select->new();
$s->add($stdout_fh);
$s->add($stderr_fh);

my $pipe_flush_str = "CRUCIBLE_PIPE_FLUSH";
my $stdout_pipe_flush_str = sprintf("STDOUT->%s\n", $pipe_flush_str);
my $stderr_pipe_flush_str = sprintf("STDERR->%s\n", $pipe_flush_str);

my $select_on_stdout : shared = 1;
my $select_on_stderr : shared = 1;

my $stdout_flush_lock = new Thread::Semaphore(1);
my $stderr_flush_lock = new Thread::Semaphore(1);

$stdout_flush_lock->down();
$stderr_flush_lock->down();

my $stdout_flusher_thread = threads->create('flusher_thread', 'stdout', $stdout_pipe, $stdout_pipe_flush_str, \$select_on_stdout, $stdout_flush_lock);
my $stderr_flusher_thread = threads->create('flusher_thread', 'stderr', $stderr_pipe, $stderr_pipe_flush_str, \$select_on_stderr, $stderr_flush_lock);


while($s->count()) {
    my @ready = $s->can_read(0.5);

    # if no file handles are ready let's flush the pipes to make sure
    # buffering is not getting in the way -- only do this if we are
    # still polling on the individual file handles
    #
    # we do this via background system calls so that they can be
    # performed asynchronously to our own reading from the pipes --
    # synchronous writes would cause a deadlock
    if (scalar(@ready) == 0) {
	if ($select_on_stdout) {
	    #print "signaling flush on 'stdout'\n";
	    $stdout_flush_lock->up();
	}
	if ($select_on_stderr) {
	    #print "signaling flush on 'stderr'\n";
	    $stderr_flush_lock->up();
	}
	next;
    }

    foreach my $fh (@ready) {
	$_ = readline($fh);
	if (!defined($_)) {
	    next;
	}

	# if a pipe flush is encountered then skip processing it
	if ($_ =~ /$pipe_flush_str/) {
	    next;
	}

	my $ts = time();
	chomp($_);

	my @var = localtime(int($ts));
	my $subsec = ($ts - int($ts))*1000;
	my $timestamp = sprintf("%04d-%02d-%02d %02d:%02d:%02d.%03d", $var[5]+1900, $var[4]+1, $var[3], $var[2], $var[1], $var[0], $subsec);

	my $stream = "0";
	my $logit = 0;
	if ($fh == $stdout_fh) {
	    $stream = "STDOUT";

	    if ($_ =~ /CRUCIBLE_CLOSE_LOG_PIPE/) {
		$s->remove($stdout_fh);
		$select_on_stdout = 0;
		$stdout_flush_lock->up();
		close($stdout_fh);
		#print("Closed STDOUT pipe\n");
		#$logit = 1;
	    } else {
		$logit = 1;
		printf("[%s][%s][STDOUT] %s\n", $timestamp, $source, $_);
	    }
	} elsif ($fh == $stderr_fh) {
	    $stream = "STDERR";

	    if ($_ =~ /CRUCIBLE_CLOSE_LOG_PIPE/) {
		$s->remove($stderr_fh);
		$select_on_stderr = 0;
		$stderr_flush_lock->up();
		close($stderr_fh);
		#print("Closed STDERR pipe\n");
		#$logit = 1;
	    } else {
		$logit = 1;
		printf(STDERR "[%s][%s][STDERR] %s\n", $timestamp, $source, $_);
	    }
	}

	if ($logit) {
	    my $rv = $log_dbh->do("INSERT INTO lines (session, timestamp, stream, line) SELECT $session_id, $ts, id, " . $log_dbh->quote($_) . " FROM streams WHERE stream=" . $log_dbh->quote($stream) . ";");
	    if ($rv < 0) {
		print $DBI::errstr;
		exit(1);
	    }
	}
    }
}

$stdout_flusher_thread->join();
$stderr_flusher_thread->join();

$log_dbh->disconnect();

unlink $stdout_pipe, $stderr_pipe;

exit;

sub flusher_thread {
    my ($type, $pipe_file, $flush_str, $loop, $lock) = @_;

    my $pipe_fh;

    while ($$loop) {
	if ($lock->down_timed(1)) {
	    if ($$loop) {
		if (open($pipe_fh, ">", $pipe_file)) {
		    #print "flushing '" . $type . "'\n";
		    printf { $pipe_fh } "%s", $flush_str;
		    close($pipe_fh);
		}
	    }
	}
    }
}

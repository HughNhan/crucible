#!/usr/bin/env bash
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4 -*-

# Crucible's purpose is to provide a single interface
# for all of these subprojects for a seamless performance
# benchmark and tool harness solution

# Crucible expects to have these subprojects (eventually):
#
# Project-name      Commands        Purpose                   Status
#
# Rickshaw          run-benchmark   Coordinate a full "run"   Not implemented
#                   clear-result    of a benchmark with one
#                                   or more iterations
#
# Multiplex         gen-iterations  Convert a user's list     Minimally viable,
#                                   of benchamrk params       Integrated
#                                   (--opt val1,val2)
#                                   into multiple benchmark
#                                   iterations
#
# <remote-exec>     auth-hosts      Automated ssh key         Not implemented
#                   ssh-hosts       installation, multi-
#                                   remote-host execution
#
# Roadblock         <TBD>           Provide synchrnization    Minimally viable,
#                                   across endpoints (hosts   Not integrated
#                                   and/or containers) and
#                                   this controller
#
# Workshop          workshop        Image management for      Under Development
#                                   endpoint execution
#
# <tools-project>   register-tool   Integrate various tools   Not implemented
#                   unregister-tool for execution
#
# <elastic/CDM>     query-elastic   Data storage, query,      Under developoment
#                   import-elastic  reporting, etc.
#                   build-elastic
#
#
# Addtionally, Crucible will work with one or more
# benchmark or tool subprojects, found in:
# ./subprojects/tools
# ./subprojects/benchmarks
# 
# These subprojects provide configuration information,
# integration scripts, and post-processing scripts
# for a specific benchmark or tool, like Fio or Iostat.

# Crucible is meant to be run from a single command, 'crucible'
# and provide all the functionality from these projects.

if [ -e /etc/sysconfig/crucible ]; then
    . /etc/sysconfig/crucible
    if [ -z "$CRUCIBLE_HOME" ]; then
        echo "\$CRUCIBLE_HOME does not appear to be defined in /etc/sysconfig/crucible, exiting"
        exit 1
    fi
else
    echo "Could not find /etc/sysconfig/crucible.  Please ensure crucible is installed first."
    exit 1
fi

if [ -z "$CRUCIBLE_HOME" ]; then
    echo "CRUCIBLE_HOME not set, exiting."
    exit 1
fi

if [ ! -e $CRUCIBLE_HOME ]; then
    echo "Could not find $CRUCIBLE_HOME, exiting."
    exit 1
fi
. $CRUCIBLE_HOME/bin/base

if [ "$CRUCIBLE_USE_CONTAINERS" == "1" -a -z "$CRUCIBLE_CONTAINER_IMAGE" ]; then
    echo "Switching to not using container because CRUCIBLE_CONTAINER_IMAGE is not defined"
    CRUCIBLE_USE_CONTAINERS="0"
fi

if [ "$CRUCIBLE_USE_CONTAINERS" == "1" ]; then
    podman --version >/dev/null
    if [ $? -gt 0 ]; then
        echo "You must have podman to use the crucible controller with containers.  Please install and run again"
        exit 1
    fi
else
    echo ""
fi

# make sure the user has a .crucible directory for storing things
USER_STORE=$HOME/.crucible
if [ ! -d ${USER_STORE} ]; then
    mkdir -v ${USER_STORE}
fi
LOG_DB=${USER_STORE}/log.db

check_id

container_log_args=()
container_log_args+=("-i")
container_log_args+=("--name crucible-log")
container_log_args+=("--mount=type=bind,source=$LOG_DB,destination=$LOG_DB")
container_log_args+=("--mount=type=bind,source=/tmp,destination=/tmp")

/bin/mkdir -p /var/opt/crucible
/bin/mkdir -p /var/lib/crucible


function crucible_log() {
    if [ "$CRUCIBLE_USE_LOGGER" == "1" ]; then
        echo podman run ${container_log_args[@]} ${container_common_args[@]} $CRUCIBLE_CONTAINER_IMAGE $CRUCIBLE_HOME/bin/log $@
        podman run ${container_log_args[@]} ${container_common_args[@]}\
            $CRUCIBLE_CONTAINER_IMAGE $CRUCIBLE_HOME/bin/log $@
    else
        $CRUCIBLE_HOME/bin/log $@
    fi
}

function setup_pipe() {
    local PIPE=${1}
    rm ${PIPE}
    mknod ${PIPE} p
}

# special case some log operations so they don't happen under log
# redirection
log_cmd="${CRUCIBLE_HOME}/bin/_logger console \"${COMMAND}\" ${USER_STORE}/log.db ${STDOUT_PIPE} ${STDERR_PIPE}"

if [ ! -e ${LOG_DB} -a "$CRUCIBLE_USE_LOGGER" == "1" ]; then
    crucible_log init ${LOG_DB}
fi

if [ "$1" == "log" ]; then
    if [ "$CRUCIBLE_USE_LOGGER" == "1" ]; then
        if [ "$2" == "view" -o -z "$2" ]; then
            shift
            shift
            crucible_log view ${LOG_DB} "$@" | less -S -F
            exit $?
        elif [ "$2" == "clear" ]; then
            crucible_log clear ${LOG_DB}
            exit $?
        elif [ "$2" == "init" ]; then
            crucible_log init ${LOG_DB}
            exit $?
        elif [ "$2" == "insert" ]; then
            shift
            shift
            crucible_log insert ${LOG_DB} "$@"
            exit $?
        elif [ "$2" == "debug" ]; then
                sqlite3 ${LOG_DB} ".headers on" \
                        ".echo on" \
                        "select * from db_state;" ".print" \
                        "select * from streams;" ".print" \
                        "select * from sources;" ".print" \
                        "select * from commands;" ".print" \
                        "select * from sessions;" ".print" \
                        "select * from lines;" \
                    | less -S -F
                exit $?
        fi
    else
        echo "log command not supported because CRUCIBLE_USE_LOGGER = 0"
        exit
    fi
elif [ "$1" == "help" ]; then
    # print all help output outside of the logger context to avoid
    # filling the log with generic help information

    shift
    exec ${CRUCIBLE_HOME}/bin/_help ${CRUCIBLE_HOME} "$@"
fi

if [ "$CRUCIBLE_USE_LOGGER" == "1" ]; then
    # disable CTRL-C killing this script while we are logging to a remote
    # process the CTRL-C should kill any subprocess other than the logger
    # and we should gracefully exit
    trap "echo 'Crucible caught CTRL-C'" INT

    # initialize the logger pipes
    STDOUT_PIPE=$(mktemp)
    STDERR_PIPE=$(mktemp)
    setup_pipe ${STDOUT_PIPE}
    setup_pipe ${STDERR_PIPE}

    COMMAND="$(basename $0) $@"
    COMMAND="`echo $COMMAND | sed -e 's/ /_/g'`"
    logger_cmd="${CRUCIBLE_HOME}/bin/_logger console \"${COMMAND}\" ${USER_STORE}/log.db ${STDOUT_PIPE} ${STDERR_PIPE}"

    container_logger_args=()
    container_logger_args+=("-i")
    container_logger_args+=("-d")
    container_logger_args+=("--name crucible-log")
    container_logger_args+=("--mount=type=bind,source=$LOG_DB,destination=$LOG_DB")
    container_logger_args+=("--mount=type=bind,source=/tmp,destination=/tmp")

    if [ "$CRUCIBLE_USE_CONTAINERS" == "1" ]; then
        podman run ${container_logger_args[@]} ${container_common_args[@]} $CRUCIBLE_CONTAINER_IMAGE $logger_cmd
    else
        $logger_cmd &
    fi
    LOGGER_PID=$!

    # redirect the output to the pipes
    # TODO: only redirct if logger is confirmed to be working
    exec > ${STDOUT_PIPE} 2> ${STDERR_PIPE}
fi

# invoke the main command handler
${CRUCIBLE_HOME}/bin/_main "${CRUCIBLE_HOME}" "${LOG_DB}" "$@"
RET_VAL=${?}

if [ "$CRUCIBLE_USE_LOGGER" == "1" ]; then
    # signal the logger that all output has been processed from each of
    # the pipes
    echo "STDOUT->CRUCIBLE_CLOSE_LOG_PIPE" > ${STDOUT_PIPE}
    echo "STDERR->CRUCIBLE_CLOSE_LOG_PIPE" > ${STDERR_PIPE}

    # wait for the logger to exit
    wait ${LOGGER_PID}
fi

exit ${RET_VAL}
